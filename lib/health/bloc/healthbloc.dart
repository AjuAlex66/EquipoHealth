import 'dart:async';
import 'dart:convert';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:equipohealth/health/model/dashboardmodel.dart';
import 'package:equipohealth/utils/featurevibration.dart';
import 'package:equipohealth/utils/helper.dart';
import 'package:equipohealth/utils/initializer.dart';
import 'package:equipohealth/utils/localstorage.dart';
import 'package:firebase_auth/firebase_auth.dart';

import 'package:http/http.dart' as http;
import 'package:flutter_bloc/flutter_bloc.dart';

class HealthBloc extends Bloc<HealthEvent, HealthState> {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  HealthBloc() : super(HealthState()) {
    on<DoRegister>(doRegister);
    on<GetDashBoardData>(getDashBoardData);
    on<DoLogin>(doLogin);
    on<GetProfileData>(getProfileData);
    on<DoLogout>(doLogout);
    on<UpdateDashboard>(updateDashBoard);
  }

  Future<FutureOr<void>> doRegister(
      DoRegister event, Emitter<HealthState> emit) async {
    try {
      emit(RegisteringUser());
      Helper.showLoading();
      try {
        List<String> signInMethods = await _auth
            .fetchSignInMethodsForEmail(event.data!['email'])
            .onError((error, stackTrace) => Helper.showSnack(error.toString()));
        if (signInMethods.isEmpty) {
          await _auth
              .createUserWithEmailAndPassword(
                  email: event.data!['email'],
                  password: event.data!['password'])
              .then((value) async {
            User user = value.user!;
            await FirebaseFirestore.instance
                .collection('equipousers')
                .doc(user.uid)
                .set({
              'name': event.data!['name'],
              'email': event.data!['email'],
              'gender': event.data!['gender'] ? "Male" : "Female",
              "_id": user.uid,
            }).then((rValue) async {
              await LocalStorage.saveUserId(user.uid);
              Helper.pop();
              Helper.showLog("register value");
              Helper.showSnack("Registration successfull");
              emit(UserRegistered());
            });
          }).onError((error, stackTrace) => Helper.showSnack(error.toString()));
        } else {
          Helper.pop();
          Helper.showSnack(
              "The email address is already in use by another account.");
          emit(UserAlreadyRegistered());
        }
      } catch (error) {
        Helper.pop();
        Helper.showLog(error.toString());
        return null;
      }
      // emit(UserRegistered());
      // emit(UserNotRegistered());
    } catch (e) {
      Helper.pop();
      emit(UserRegisterFailed());
    }
  }

  Future<FutureOr<void>> getDashBoardData(
      GetDashBoardData event, Emitter<HealthState> emit) async {
    // List<Autogenerated> autogenerated =
    //     await getData('https://fakestoreapi.com/products').then((value) => {
    //       for
    //     });
    // Helper.showLog(autogenerated);
    try {
      QuerySnapshot<Map<String, dynamic>> data = await _firestore
          .collection('euipocollections')
          .where('_id', isEqualTo: Initializer.userId)
          .get();
      if (data.docs.isNotEmpty) {
        for (var doc in data.docs) {
          Helper.showLog(doc.data());
          Map<String, dynamic> jsonData = doc.data();
          HealthData healthData = HealthData.fromJson(jsonData);
          Helper.showLog(healthData);
          emit(DashBoardDataFetched(healthData: healthData));
          break;
        }
      } else {
        emit(DashBoardDataNotFound());
      }
    } catch (e) {
      Helper.showLog('exception in $e');
      emit(DashBoardDataNotFetched());
    }
  }

  Future<FutureOr<void>> doLogin(
      DoLogin event, Emitter<HealthState> emit) async {
    try {
      emit(Logging());
      Helper.showLoading();
      UserCredential? userCredential;
      List<String> methods = await FirebaseAuth.instance
          .fetchSignInMethodsForEmail(event.data!['email']);
      if (methods.isEmpty) {
        Helper.pop();
        Helper.showSnack("This email address is not registered, please signup");
      } else {
        userCredential = await FirebaseAuth.instance.signInWithEmailAndPassword(
            email: event.data!['email'], password: event.data!['password']);
        if (userCredential.user!.uid.isNotEmpty) {
          Initializer.userId = userCredential.user!.uid;
          await LocalStorage.saveUserId(userCredential.user!.uid);
          Helper.pop();
          emit(LoggingSuccess());
        } else {
          Helper.showSnack("Login failed");
          Helper.pop();
          emit(LoggingFailed());
        }
      }
      Helper.showLog(userCredential!.additionalUserInfo!.isNewUser);
    } catch (e) {
      emit(LoggingFailed());
      Helper.pop();
      Helper.showSnack(e.toString());
      Helper.showLog("Exception on signin $e");
    }
  }

  getData(String s) async {
    var response = await http.get(
      Uri.parse(s),
      headers: {"Content-Type": "application/json", "x-auth-token": ""},
    );

    if (response.statusCode == 200) {
      return jsonDecode(response.body);
    } else {
      var error = {
        "status": false,
        "msg": "${response.statusCode} - ${response.reasonPhrase}"
      };
      return error;
    }
  }

  FutureOr<void> getProfileData(
      GetProfileData event, Emitter<HealthState> emit) async {
    try {
      emit(GettingProfileData());
      Initializer.userData = await _firestore
          .collection('equipousers')
          .where("_id", isEqualTo: Initializer.userId!)
          .get();
      emit(ProfileDataFetched());
    } catch (e) {
      emit(ProfileDataNotFecthed());
    }
  }

  Future<FutureOr<void>> doLogout(
      DoLogout event, Emitter<HealthState> emit) async {
    try {
      emit(LoggingOut());
      Helper.showLoading();
      await Helper.makeADelay(delayInMilliseconds: 600);
      await _auth.signOut().then((value) async {
        await Helper.makeADelay(delayInMilliseconds: 600);
        Helper.pop();
        emit(LoggingOutSuccess());
      });
    } catch (e) {
      Helper.pop();
      emit(LoggingOutFailed());
    }
  }

  Future<FutureOr<void>> updateDashBoard(
      UpdateDashboard event, Emitter<HealthState> emit) async {
    try {
      emit(UpdatingDashBoard());
      Helper.showLoading();
      await _firestore.collection('euipocollections').add({
        "_id": Initializer.userId,
        "overall": [
          {
            "title": "Blood Pressure",
            "value":
                "${Initializer.dashboardInputModel.bloodHigher}/${Initializer.dashboardInputModel.bloodLower}",
            "unit": "mmHg"
          },
          {
            "title": "Heart Rate",
            "value": Initializer.dashboardInputModel.heartRate,
            "unit": "BPM"
          },
          {
            "title": "Sleep",
            "value": Initializer.dashboardInputModel.sleepHour,
            "unit": "Hours"
          },
          {
            "title": "Calories",
            "value": Initializer.dashboardInputModel.calorieRate,
            "unit": "Kcal"
          }
        ],
        "appointment": {
          "date": DateTime.now(),
          "referel": Initializer.dashboardInputModel.doctorName
        },
        "medications": [
          {
            "description": "Take one tablet once a day",
            "due": DateTime.now(),
            "medicinename": Initializer.dashboardInputModel.mediceName1
          },
          {
            "description": "Take one tablet once a day",
            "due": DateTime.now(),
            "medicinename": Initializer.dashboardInputModel.mediceName2
          },
          {
            "description": "Take one tablet once a day",
            "due": DateTime.now(),
            "medicinename": Initializer.dashboardInputModel.mediceName3
          }
        ],
      }).then((value) {
        Helper.pop();
        FeatureVibration.success();
        Helper.showSnack("Dashboard data updated!");
        emit(DashBoardUpdated());
      });
    } catch (e) {
      Helper.pop();
      emit(DashBoardNotUpdated());
    }
  }
}

class HealthState {}

class HealthEvent {}

// class GetDashBoardData extends HealthEvent {}

// class GettingDashBoardData extends HealthState {}
// class

class DoRegister extends HealthEvent {
  final Map? data;
  DoRegister({required this.data});
}

class RegisteringUser extends HealthState {}

class UserRegistered extends HealthState {}

class UserAlreadyRegistered extends HealthState {}

class UserNotRegistered extends HealthState {}

class UserRegisterFailed extends HealthState {}

class GetDashBoardData extends HealthEvent {}

class DashBoardDataFetched extends HealthState {
  final HealthData? healthData;
  DashBoardDataFetched({required this.healthData});
}

class DashBoardDataNotFetched extends HealthState {}

class DashBoardDataNotFound extends HealthState {}

class DoLogin extends HealthEvent {
  final Map? data;
  DoLogin({required this.data});
}

class Logging extends HealthState {}

class LoggingSuccess extends HealthState {}

class LoggingFailed extends HealthState {}

class GetProfileData extends HealthEvent {}

class GettingProfileData extends HealthState {}

class ProfileDataFetched extends HealthState {}

class ProfileDataNotFecthed extends HealthState {}

class DoLogout extends HealthEvent {}

class LoggingOut extends HealthState {}

class LoggingOutSuccess extends HealthState {}

class LoggingOutFailed extends HealthState {}

class UpdateDashboard extends HealthEvent {}

class UpdatingDashBoard extends HealthState {}

class DashBoardUpdated extends HealthState {}

class DashBoardNotUpdated extends HealthState {}
